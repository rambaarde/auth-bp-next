import * as path from 'path';
import * as fs from 'fs-extra';

export interface ContextConfig {
  whitelabel: boolean;
  rbac: boolean;
  multitenant: boolean;
  database: 'supabase' | 'google-cloud-sql';
  backendUrl: string;
}

/**
 * Context Generator
 * 
 * Creates .context.md files in key directories to help AI assistants
 * (Copilot, Cursor, etc.) understand code structure and architecture
 * without hallucinating incorrect patterns.
 * 
 * Generated files:
 * - .context.md (root) - Project overview
 * - app/api/auth/.context.md - NextAuth configuration
 * - components/auth/.context.md - Auth form components
 * - middleware/.context.md - Request routing and tenant handling
 * - lib/.context.md - API client and auth utilities
 */

export async function generateContextFiles(projectRoot: string, config: ContextConfig): Promise<void> {
  // Root context
  await generateRootContext(projectRoot, config);

  // API auth context
  await generateApiAuthContext(projectRoot, config);

  // Components auth context
  await generateComponentsAuthContext(projectRoot, config);

  // Middleware context
  await generateMiddlewareContext(projectRoot, config);

  // Lib context
  await generateLibContext(projectRoot, config);
}

async function generateRootContext(projectRoot: string, config: ContextConfig): Promise<void> {
  const content = generateRootContextContent(config);
  const filePath = path.join(projectRoot, '.context.md');
  await fs.writeFile(filePath, content, 'utf-8');
}

async function generateApiAuthContext(projectRoot: string, config: ContextConfig): Promise<void> {
  const content = generateApiAuthContextContent(config);
  const dirPath = path.join(projectRoot, 'app', 'api', 'auth');
  await fs.ensureDir(dirPath);
  const filePath = path.join(dirPath, '.context.md');
  await fs.writeFile(filePath, content, 'utf-8');
}

async function generateComponentsAuthContext(projectRoot: string, config: ContextConfig): Promise<void> {
  const content = generateComponentsAuthContextContent(config);
  const dirPath = path.join(projectRoot, 'components', 'auth');
  await fs.ensureDir(dirPath);
  const filePath = path.join(dirPath, '.context.md');
  await fs.writeFile(filePath, content, 'utf-8');
}

async function generateMiddlewareContext(projectRoot: string, config: ContextConfig): Promise<void> {
  const content = generateMiddlewareContextContent(config);
  const filePath = path.join(projectRoot, 'middleware.context.md');
  await fs.writeFile(filePath, content, 'utf-8');
}

async function generateLibContext(projectRoot: string, config: ContextConfig): Promise<void> {
  const content = generateLibContextContent(config);
  const dirPath = path.join(projectRoot, 'lib');
  await fs.ensureDir(dirPath);
  const filePath = path.join(dirPath, '.context.md');
  await fs.writeFile(filePath, content, 'utf-8');
}

// ============================================================================
// CONTEXT CONTENT GENERATORS
// ============================================================================

function generateRootContextContent(config: ContextConfig): string {
  return `# Auth Boilerplate - Next.js Frontend Context

**Generated by auth-bp-next v1.0.0**

## Project Overview

This is a production-ready Next.js (App Router) authentication frontend that pairs with the **auth-bp-nest** NestJS backend.

### Configuration
- **Database**: ${config.database === 'supabase' ? 'Supabase PostgreSQL' : 'Google Cloud SQL PostgreSQL'}
- **Whitelabel**: ${config.whitelabel ? '✅ Enabled' : '❌ Disabled'}
- **RBAC**: ${config.rbac ? '✅ Enabled' : '❌ Disabled'}
- **Multitenant**: ${config.multitenant ? '✅ Enabled' : '❌ Disabled'}
- **Backend URL**: \`${config.backendUrl}\`

## Architecture

### Technology Stack
- **Framework**: Next.js 14+ (App Router)
- **Auth**: NextAuth.js v4
- **HTTP Client**: Axios
- **Styling**: Tailwind CSS
- **Runtime**: Node.js 16+

### Key Directories
\`\`\`
app/
├── api/auth/[...nextauth]/route.ts    # NextAuth handler
├── login/                              # Login page
└── register/                           # Registration page

components/
├── auth/
│   ├── login-form.tsx                 # Login form component
│   ├── register-form.tsx              # Registration form component
│   └── auth-provider.tsx              # Session provider wrapper

lib/
├── auth.config.ts                     # Auth configuration
├── api-client.ts                      # Axios client with JWT injection
\${config.rbac ? '└── rbac-helpers.ts                # Role checking utilities' : ''}

middleware.ts                           # NextAuth & routing middleware
\${config.multitenant ? '                                       # Handles subdomain extraction' : ''}
\`\`\`

## Data Flow: Client → Next.js → NestJS Backend

### 1. User Registration
\`\`\`
RegisterForm (components/auth/register-form.tsx)
    ↓
POST /auth/register
    ↓
api-client.ts (Axios with JWT)
    ↓
[Backend: auth-bp-nest]
POST http://localhost:3001/auth/register
    ↓
PostgreSQL (${config.database})
    ↓
Response: { accessToken, user }
    ↓
Redirect → /login
\`\`\`

### 2. User Login
\`\`\`
LoginForm (components/auth/login-form.tsx)
    ↓
signIn('credentials', { email, password })
    ↓
NextAuth CredentialsProvider
    ↓
POST http://localhost:3001/auth/login
    ↓
JWT Token returned + Session created
    ↓
Redirect → /dashboard
\`\`\`

### 3. API Requests with JWT
\`\`\`
Client Component
    ↓
useSession() hook
    ↓
Extract accessToken from session
    ↓
api-client.ts
    ↓
Request Interceptor:
  Authorization: Bearer <JWT>
    ↓
[Backend API]
    ↓
Response → Update UI
\`\`\`

## NextAuth Flow

### Configuration File: lib/auth.config.ts
- Contains backend URL
- Session duration (30 days)
- JWT secret key

### Route Handler: app/api/auth/[...nextauth]/route.ts
- **Provider**: CredentialsProvider (for username/password)
- **Callbacks**:
  - \`jwt\`: Store user info + accessToken in JWT
  - \`session\`: Expose JWT data to client
- **Pages**:
  - Sign in: \`/login\`
  - Error: \`/login?error=CredentialsSignin\`
- **Session Strategy**: JWT (stateless)

### Middleware: middleware.ts
- Protects routes that start with /dashboard, /profile, etc.
- ${config.multitenant ? 'Extracts subdomain and rewrites to /mp/[tenant]' : 'Validates authentication status'}
- ${config.rbac ? 'Checks user roles from JWT token' : 'Standard auth guard'}

## Session Object

After successful login, the session object contains:

\`\`\`typescript
interface Session {
  user: {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    accessToken: string;  // JWT to send to backend
    ${config.rbac ? 'roles?: string[];' : ''}
    ${config.multitenant ? 'tenantId?: string;' : ''}
  };
  expires: string;
}
\`\`\`

Access in client components:
\`\`\`typescript
const { data: session } = useSession();
console.log(session?.user?.accessToken);
\`\`\`

## Common Tasks

### 1. Add Protected Route
\`\`\`typescript
// app/dashboard/page.tsx
import { ProtectedRoute } from '@/components/auth/protected-route';

export default function DashboardPage() {
  return (
    <ProtectedRoute>
      <h1>Welcome to Dashboard</h1>
    </ProtectedRoute>
  );
}
\`\`\`

### 2. Call Backend API
\`\`\`typescript
import { apiClient } from '@/lib/api-client';

const response = await apiClient.post('/auth/profile', {});
const user = response.data;
\`\`\`

### 3. Check User Role (RBAC)
\`\`\`typescript
${config.rbac ? `import { useRBAC } from '@/hooks/use-rbac';

export function AdminPanel() {
  const { hasRole } = useRBAC();
  
  if (!hasRole('admin')) {
    return <div>Access Denied</div>;
  }
  
  return <div>Admin Panel</div>;
}` : 'RBAC is disabled in this project'}
\`\`\`

### 4. Multi-Tenant Setup
\`\`\`typescript
${config.multitenant ? `import { useTenant } from '@/hooks/use-tenant';

export function TenantInfo() {
  const { tenantId, hasTenant } = useTenant();
  
  return <div>Tenant: {tenantId}</div>;
}` : 'Multitenant is disabled in this project'}
\`\`\`

## Environment Variables

See \`.env.local\` for:
- \`NEXT_PUBLIC_API_URL\` - Backend API endpoint
- \`NEXTAUTH_SECRET\` - JWT signing key
- \`NEXTAUTH_URL\` - Your app URL
- ${config.database === 'supabase' ? '\`NEXT_PUBLIC_SUPABASE_URL\` - Supabase project URL' : '\`GOOGLE_CLOUD_SQL_*\` - GCP connection details'}

## Important Notes

### 1. JWT Token Management
- JWT is stored in NextAuth session (encrypted)
- Automatically attached to all API requests via \`api-client.ts\`
- Never stored in localStorage
- Refreshed automatically when expired

### 2. CORS Configuration
- Frontend: http://localhost:3000
- Backend: http://localhost:3001
- Backend must allow CORS from frontend URL

### 3. Database Consistency
Both frontend (.env.local) and backend (.env) must reference:
- Same database (Supabase or Google Cloud SQL)
- Same PostgreSQL connection string
- This ensures data consistency

### 4. Common Issues

**Problem**: 401 Unauthorized on API calls
**Solution**: 
- Check \`api-client.ts\` interceptors are adding JWT
- Verify JWT is in session via \`useSession()\`
- Confirm backend is validating JWT signature

**Problem**: Session not persisting after page refresh
**Solution**:
- NextAuth stores session in encrypted cookie
- Check \`NEXTAUTH_SECRET\` is set in .env.local
- Verify \`NEXTAUTH_URL\` matches your domain

**Problem**: 403 Forbidden on admin routes (RBAC)
**Solution**:
- Check user has 'admin' role in database
- Verify backend returns roles in login response
- Confirm middleware.ts is checking roles header

## See Also
- NextAuth.js Docs: https://next-auth.js.org
- Backend: auth-bp-nest (NestJS boilerplate)
- Database: ${config.database === 'supabase' ? 'https://supabase.com' : 'https://cloud.google.com/sql'}
`;
}

function generateApiAuthContextContent(config: ContextConfig): string {
  return `# NextAuth Configuration Context

**Location**: \`app/api/auth/[...nextauth]/route.ts\`

## Module Purpose

This directory contains the NextAuth.js handler that manages:
- User authentication with credentials
- JWT token generation and validation
- Session management
- Callback handlers for custom logic

## How NextAuth Works

### 1. CredentialsProvider
When user submits login form with email/password:

\`\`\`
1. User submits form → components/auth/login-form.tsx
2. signIn('credentials', { email, password })
3. NextAuth calls CredentialsProvider.authorize()
4. We POST to backend: POST http://localhost:3001/auth/login
5. Backend validates password, returns JWT
6. NextAuth creates encrypted session with JWT
7. Redirect to /dashboard
\`\`\`

### 2. JWT Callbacks
NextAuth callbacks intercept token creation/refresh:

**jwt() callback**:
- Triggered after successful login
- Store accessToken from backend in JWT
- Add user info (firstName, lastName, roles, etc.)
- JWT is stored in encrypted cookie

**session() callback**:
- Triggered when client calls useSession()
- Expose JWT data to frontend
- Return Session object with accessToken

### 3. Redirect Pages
- **signIn**: \`/login\` - Where to send failed auth
- **error**: \`/login?error=CredentialsSignin\` - Error display

## Configuration Details

\`\`\`typescript
authOptions: NextAuthOptions = {
  providers: [CredentialsProvider(...)],
  pages: { signIn: '/login', error: '/login' },
  callbacks: { jwt, session },
  session: { strategy: 'jwt', maxAge: 30 * 24 * 60 * 60 }
}
\`\`\`

## Token Structure

After login, the JWT token contains:

\`\`\`json
{
  "sub": "user-id",
  "email": "user@example.com",
  "firstName": "John",
  "lastName": "Doe",
  "accessToken": "eyJhbGc...", // Backend JWT for API calls
  ${config.rbac ? '"roles": ["user", "admin"],' : ''}
  ${config.multitenant ? '"tenantId": "acme-corp",' : ''}
  "iat": 1234567890,
  "exp": 1234567890
}
\`\`\`

## Backend Communication

### User Registration
\`\`\`
Next.js Client
  ↓
POST /api/auth/register
  ↓
Backend: POST ${config.backendUrl}/auth/register
  ↓
Response: { accessToken, user: { id, email, ... } }
\`\`\`

### User Login
\`\`\`
Next.js Client
  ↓
signIn('credentials', { email, password })
  ↓
authorize() function
  ↓
Backend: POST ${config.backendUrl}/auth/login
  ↓
Response: { accessToken, user: { ... } }
  ↓
JWT created with accessToken inside
\`\`\`

## Important Notes

1. **accessToken Storage**: The JWT returned from backend is stored INSIDE the NextAuth JWT
   - Never stored in localStorage
   - Automatically sent to all API requests

2. **Session Duration**: Configured to 30 days
   - User stays logged in for 30 days
   - Can be changed in \`session.maxAge\`

3. **CORS**: Backend must allow requests from frontend origin
   - Ensure ${config.backendUrl} has CORS configured
   - Allow Origin: http://localhost:3000

4. **Secret Key**: NEXTAUTH_SECRET must be set in .env.local
   - Used to encrypt JWT in cookie
   - Change in production!

## Common Modifications

### Add OAuth Provider (Google, GitHub)
\`\`\`typescript
import GoogleProvider from 'next-auth/providers/google';

providers: [
  CredentialsProvider(...),
  GoogleProvider({
    clientId: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
  }),
]
\`\`\`

### Custom Role-Based Callback
\`\`\`typescript
callbacks: {
  async jwt({ token, user }) {
    if (user?.roles) {
      token.roles = user.roles;
    }
    return token;
  },
}
\`\`\`

### Add Custom Claims to Token
\`\`\`typescript
async jwt({ token, user }) {
  if (user) {
    token.customField = user.customField;
  }
  return token;
}
\`\`\`

## See Also
- NextAuth.js: https://next-auth.js.org
- Backend Handler: ${config.backendUrl}/auth
- Session Hook: \`lib/auth.config.ts\`
`;
}

function generateComponentsAuthContextContent(config: ContextConfig): string {
  return `# Authentication Components Context

**Location**: \`components/auth/\`

## Module Purpose

Contains reusable React components for authentication flows:
- LoginForm - Email/password login
- RegisterForm - User registration
- AuthProvider - NextAuth session provider wrapper
- ProtectedRoute - Protected page wrapper
${config.rbac ? '\nRBAC Components (if enabled):' : ''}
${config.rbac ? '- Can - Conditional render if user has role' : ''}
${config.rbac ? '- Cannot - Conditional render if user lacks role' : ''}

## Component Breakdown

### LoginForm (login-form.tsx)

**Type**: Client Component ('use client')
**Props**: ${config.whitelabel ? 'logo?, primaryColor?, brandName?' : 'None'}
**Purpose**: Handle user login

**Flow**:
\`\`\`
1. User enters email + password
2. Submit → signIn('credentials', { email, password })
3. NextAuth sends to backend
4. Backend validates, returns JWT
5. Session created
6. Redirect → /dashboard
7. On error → display error message
\`\`\`

**Features**:
- Email validation
- Loading state
- Error display
${config.whitelabel ? '- Dynamic branding (logo, color, brand name)' : '- Static blue theme'}
- Link to register page

${config.whitelabel ? `
**Whitelabel Props Example**:
\`\`\`tsx
<LoginForm 
  logo="/acme-logo.png"
  primaryColor="#ff0000"
  brandName="ACME Corp"
/>
\`\`\`
` : ''}

### RegisterForm (register-form.tsx)

**Type**: Client Component ('use client')
**Purpose**: Handle new user registration

**Flow**:
\`\`\`
1. User enters: email, firstName, lastName, password
2. Validate passwords match
3. POST to /auth/register via api-client
4. Backend creates user in database
5. Redirect → /login?registered=true
6. On error → display validation error
\`\`\`

**Features**:
- Email validation
- Password strength check
- Password confirmation
- Loading state
- Error handling
${config.multitenant ? '- Optional: tenantId field' : ''}
${config.whitelabel ? '- Dynamic branding' : ''}

**Backend Integration**:
\`\`\`
POST /auth/register
{
  "email": "user@example.com",
  "firstName": "John",
  "lastName": "Doe",
  "password": "SecurePass123!",
  ${config.whitelabel ? '"brandId": "acme",' : ''}
  ${config.multitenant ? '"tenantId": "tenant-uuid"' : ''}
}
\`\`\`

### AuthProvider (auth-provider.tsx)

**Type**: Client Component ('use client')
**Purpose**: Wrap app with NextAuth SessionProvider

**Usage**:
\`\`\`tsx
// app/layout.tsx
import { AuthProvider } from '@/components/auth/auth-provider';

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <AuthProvider>
          {children}
        </AuthProvider>
      </body>
    </html>
  );
}
\`\`\`

**Effect**: Enables useSession() in all child components

### ProtectedRoute (protected-route.tsx)

**Type**: Client Component ('use client')
**Purpose**: Gate components behind authentication

**Usage**:
\`\`\`tsx
// app/dashboard/page.tsx
import { ProtectedRoute } from '@/components/auth/protected-route';

export default function DashboardPage() {
  return (
    <ProtectedRoute>
      <h1>Dashboard</h1>
    </ProtectedRoute>
  );
}
\`\`\`

**Behavior**:
- Show loading spinner while checking session
- If authenticated → render children
- If not authenticated → show "Please log in" + link to /login

${config.rbac ? `
### Can Component (components/rbac/can.tsx)

**Type**: Client Component
**Purpose**: Conditional render based on user role

**Usage**:
\`\`\`tsx
import { Can } from '@/components/rbac/can';

<Can role="admin">
  <button>Delete User</button>
</Can>
\`\`\`

**Props**:
- \`role\`: string | string[] - Required role(s)
- \`children\`: ReactNode - Render if user has role
- \`fallback\`: ReactNode - Render if user lacks role

**Behavior**:
- Checks \`user.roles\` from session
- If array: checks if user has ANY role (OR logic)
- If string: checks exact match

### Cannot Component (components/rbac/cannot.tsx)

**Type**: Client Component
**Purpose**: Render only if user lacks role (inverse of Can)

**Usage**:
\`\`\`tsx
<Cannot role="admin">
  <p>You need admin access</p>
</Cannot>
\`\`\`
` : ''}

## State Management

All components use React hooks:
- \`useState\` - Form state, loading, errors
- \`useRouter\` - Navigation after auth
- \`useSession\` - Access current user session
${config.rbac ? '- \`useRBAC\` - Check user roles' : ''}

## Session Access

In any client component:

\`\`\`tsx
'use client';
import { useSession } from 'next-auth/react';

export function MyComponent() {
  const { data: session, status } = useSession();
  
  if (status === 'loading') return <div>Loading...</div>;
  if (status === 'unauthenticated') return <div>Not logged in</div>;
  
  return <div>Hello {session?.user?.firstName}</div>;
}
\`\`\`

## API Integration

Forms use \`apiClient\` from \`lib/api-client.ts\`:

\`\`\`tsx
import { apiClient } from '@/lib/api-client';

const response = await apiClient.post('/auth/register', {
  email, firstName, lastName, password
});
\`\`\`

**Key Feature**: apiClient automatically adds JWT Bearer token to all requests.

## Styling

Components use Tailwind CSS:
- Responsive design
- Dark mode support possible
- Custom via primaryColor prop (whitelabel)

## Common Patterns

### Redirect Authenticated Users from Login Page
\`\`\`tsx
'use client';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';

export default function LoginPage() {
  const { status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === 'authenticated') {
      router.push('/dashboard');
    }
  }, [status, router]);

  return <LoginForm />;
}
\`\`\`

### Disable Form Submission During Load
\`\`\`tsx
<button disabled={loading}>
  {loading ? 'Signing in...' : 'Sign in'}
</button>
\`\`\`

### Show User Profile After Login
\`\`\`tsx
const { data: session } = useSession();
console.log(session?.user?.email);
console.log(session?.user?.firstName);
\`\`\`

## See Also
- Backend: auth-bp-nest API docs
- NextAuth: https://next-auth.js.org
- API Client: lib/api-client.ts
`;
}

function generateMiddlewareContextContent(config: ContextConfig): string {
  return `# Middleware Context

**Location**: \`middleware.ts\`

## Module Purpose

The middleware intercepts EVERY request to your Next.js app:
${config.multitenant ? '- Extract subdomain and rewrite to /mp/[tenant] route' : '- Enforce authentication on protected routes'}
${config.rbac ? '- Verify user roles from JWT token' : ''}
- Redirect unauthenticated users to /login
- Inject user context into request headers

## Execution Flow

Every HTTP request follows this sequence:

\`\`\`
1. Browser Request
   ↓
2. Middleware (middleware.ts)
   ├─ Check if route is public (allow)
   ${config.multitenant ? '├─ Extract subdomain from Host header' : ''}
   ${config.multitenant ? '├─ Rewrite to /mp/[tenant] if found' : ''}
   ${config.rbac ? '├─ Decode JWT from next-auth.session-token cookie' : ''}
   ${config.rbac ? '├─ Extract user roles' : ''}
   ${config.rbac ? '├─ Add x-user-roles header to request' : ''}
   ├─ Verify user is authenticated
   └─ Allow or redirect to /login
   ↓
3. Route Handler / Page Component
   ${config.rbac ? '   ├─ Access req.headers.get("x-user-roles")' : ''}
   └─ Render or respond
\`\`\`

## Public vs Protected Routes

### Public Routes (no auth required)
\`\`\`
/login
/register
/forgot-password
/reset-password
/api/auth/*
\`\`\`

Requests to these routes bypass authentication checks.

### Protected Routes (auth required)
\`\`\`
/dashboard
/profile
${config.rbac ? '/admin' : ''}
${config.multitenant ? '/mp' : ''}
\`\`\`

Requests without valid session are redirected to /login.

## Configuration Details

### Matcher Pattern
\`\`\`typescript
export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
};
\`\`\`

Middleware runs on all routes EXCEPT:
- \`/api/*\` - API routes (handled separately)
- \`/_next/static/*\` - Build artifacts
- \`/_next/image/*\` - Image optimization
- \`/favicon.ico\` - Static file

${config.multitenant ? `
## Multitenant Routing

### Subdomain Extraction

The middleware extracts tenant identifier from subdomain:

\`\`\`
tenant.localhost:3000       → tenant = "tenant"
acme.example.com            → tenant = "acme"
app.company.co.uk           → tenant = "app"
www.example.com             → tenant = null (www ignored)
example.com                 → tenant = null (no subdomain)
192.168.1.1:3000            → tenant = null (IP address)
\`\`\`

### Regex Validation
\`\`\`typescript
function extractSubdomain(host: string): string | null {
  // Must contain only lowercase alphanumeric + hyphens
  const validTenantRegex = /^[a-z0-9-]+$/;
  
  if (!validTenantRegex.test(potentialTenant)) {
    return null;
  }
  
  return potentialTenant;
}
\`\`\`

### URL Rewriting
When subdomain is detected, middleware rewrites the request:

\`\`\`
Original Request:
  Host: acme.example.com
  Path: /users
  
Rewritten To:
  Path: /mp/acme/users
  
Route Handler:
  app/mp/[tenant]/users/page.tsx
\`\`\`

### Example: Multi-tenant Dashboard
\`\`\`
Browser:  acme.example.com/dashboard
          ↓
Middleware:
  1. Extract "acme" from subdomain
  2. Rewrite to /mp/acme/dashboard
  
Route Handler:
  app/mp/[tenant]/dashboard/page.tsx
  
Access tenant ID:
  const { tenant } = useParams();
  // tenant = "acme"
\`\`\`

### Tenant Context in Route Handlers
\`\`\`typescript
// app/mp/[tenant]/page.tsx
import { useParams } from 'next/navigation';

export default function TenantPage() {
  const { tenant } = useParams();
  
  // tenant = subdomain from URL
  return <div>Welcome to {tenant}</div>;
}
\`\`\`
` : ''}

${config.rbac ? `
## RBAC Implementation

### JWT Token Decoding

The middleware extracts and decodes the NextAuth JWT:

\`\`\`typescript
function extractUserRolesFromToken(request: NextRequest): string[] | null {
  // 1. Get JWT from secure cookie
  const token = request.cookies.get('next-auth.session-token')?.value;
  
  // 2. Split JWT: header.payload.signature
  const parts = token.split('.');
  
  // 3. Decode payload (base64url decode)
  const payload = JSON.parse(
    Buffer.from(parts[1], 'base64').toString()
  );
  
  // 4. Extract roles from decoded JWT
  return payload.roles || [];
}
\`\`\`

### Request Header Injection

User roles are added to request headers for route handlers:

\`\`\`typescript
const requestHeaders = new Headers(request.headers);
requestHeaders.set('x-user-roles', JSON.stringify(['user', 'admin']));

return NextResponse.next({
  request: { headers: requestHeaders },
});
\`\`\`

### Checking Roles in Route Handlers

\`\`\`typescript
// app/api/admin/users/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  const rolesHeader = request.headers.get('x-user-roles');
  
  if (!rolesHeader?.includes('admin')) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 403 }
    );
  }
  
  // User has admin role, proceed
  return NextResponse.json({ users: [] });
}
\`\`\`

### Helper Function

Use the exported \`hasRole\` function:

\`\`\`typescript
import { hasRole } from '@/middleware';

const roles = request.headers.get('x-user-roles');
if (!hasRole(roles, 'admin')) {
  return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
}
\`\`\`
` : ''}

## Token Refresh & Expiration

NextAuth automatically refreshes expired tokens:

\`\`\`
1. User makes request with expired JWT
2. Backend returns 401 Unauthorized
3. Middleware catches this
4. User redirected to /login
5. NextAuth clears session
6. User must log in again
\`\`\`

No manual token refresh needed - NextAuth handles it.

## Common Issues

### Issue: Routes not protected
**Solution**: Ensure route is not in PUBLIC_ROUTES array

### Issue: Roles not available in route handler
**Solution**: Check middleware is running (verify matcher pattern)

### Issue: Subdomain not being extracted (Multitenant)
**Solution**: 
- Verify Host header format (e.g., tenant.localhost:3000)
- Check tenant matches regex /^[a-z0-9-]+$/

### Issue: Redirect loop on /login
**Solution**:
- Ensure /login is in PUBLIC_ROUTES
- Check NEXTAUTH_URL matches your domain

## Performance Notes

Middleware runs on EVERY request, so keep it fast:
- Token decoding: ~1ms
- Subdomain extraction: <1ms
- Total overhead: <5ms per request

## See Also
- NextAuth Middleware: https://next-auth.js.org/deployment/edge
- Backend RBAC: auth-bp-nest backend documentation
- API Client: lib/api-client.ts (token injection)
`;
}

function generateLibContextContent(config: ContextConfig): string {
  return `# Library Utilities Context

**Location**: \`lib/\`

## Module Purpose

Central location for utility functions and configurations:
- \`auth.config.ts\` - Authentication settings
- \`api-client.ts\` - HTTP client with JWT injection
${config.rbac ? '- RBAC helper functions' : ''}

## auth.config.ts

**Purpose**: Central config for auth settings

\`\`\`typescript
export const authConfig = {
  backendUrl: process.env.NEXT_PUBLIC_API_URL,
  sessionMaxAge: 30 * 24 * 60 * 60,
  jwtSecretKey: process.env.NEXTAUTH_SECRET,
};
\`\`\`

**Usage**:
\`\`\`typescript
import { authConfig } from '@/lib/auth.config';

// Get backend URL for API calls
fetch(\`\${authConfig.backendUrl}/auth/profile\`);
\`\`\`

## api-client.ts

**Purpose**: Axios instance pre-configured for backend API calls

### Features

1. **Automatic JWT Injection**
   \`\`\`
   Every request automatically includes:
   Authorization: Bearer <JWT-from-session>
   \`\`\`

2. **Request Interceptor**
   \`\`\`typescript
   // Before every request:
   // 1. Get session via getSession()
   // 2. Extract accessToken
   // 3. Add to Authorization header
   \`\`\`

3. **Response Interceptor**
   \`\`\`typescript
   // After every response:
   // 1. If 401 Unauthorized:
   //    - Session is invalid
   //    - Redirect to /login
   //    - User must re-authenticate
   \`\`\`

### Usage Examples

**GET Request**:
\`\`\`typescript
import { apiClient } from '@/lib/api-client';

const data = await apiClient.get('/auth/profile');
console.log(data.data); // User profile
\`\`\`

**POST Request**:
\`\`\`typescript
const response = await apiClient.post('/auth/register', {
  email: 'user@example.com',
  firstName: 'John',
  lastName: 'Doe',
  password: 'SecurePass123!',
});
\`\`\`

**Type-Safe Requests**:
\`\`\`typescript
interface User {
  id: string;
  email: string;
  firstName: string;
}

const response = await apiClient.get<User>('/auth/profile');
const user: User = response.data;
\`\`\`

**Using Fetch Helper**:
\`\`\`typescript
import { fetchFromBackend } from '@/lib/api-client';

const user = await fetchFromBackend<User>('GET', '/auth/profile');
\`\`\`

### Error Handling

\`\`\`typescript
try {
  const data = await apiClient.post('/auth/login', {...});
} catch (error) {
  if (error.response?.status === 401) {
    // Unauthorized - handled by interceptor
  } else if (error.response?.status === 400) {
    // Bad request - show validation error
    console.log(error.response.data.message);
  }
}
\`\`\`

## Data Flow: Client → API Client → Backend

\`\`\`
React Component
  ↓
apiClient.post('/auth/login', { ... })
  ↓
Request Interceptor
  ├─ getSession()
  ├─ Extract accessToken
  └─ Add Authorization header
  ↓
POST ${config.backendUrl}/auth/login
  ↓
Backend Validation
  ├─ Verify JWT signature
  ├─ Check user exists
  └─ Return 200 or 401
  ↓
Response Interceptor
  ├─ If 200: Return data
  └─ If 401: Redirect to /login
  ↓
Component receives data / redirects
\`\`\`

## Session Integration

The api-client uses \`getSession()\` from next-auth/react:

\`\`\`typescript
import { getSession } from 'next-auth/react';

const session = await getSession();
// session.user.accessToken = JWT from backend
\`\`\`

**Note**: Only works in Client Components ('use client')

### Server-Side API Calls

For server components, use NextAuth session differently:

\`\`\`typescript
// app/dashboard/page.tsx (Server Component)
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';

export default async function Dashboard() {
  const session = await getServerSession(authOptions);
  
  if (!session) {
    // Not authenticated
  }
  
  // Use session.user.accessToken for API calls
}
\`\`\`

## Backend Endpoints

Common endpoints this client communicates with:

| Endpoint | Method | Purpose |
|----------|--------|---------|
| /auth/login | POST | User login |
| /auth/register | POST | User registration |
| /auth/profile | GET | Get current user |
| /auth/logout | POST | Logout user |
| /auth/refresh | POST | Refresh token |
${config.rbac ? '| /rbac/roles | GET | List roles |' : ''}
${config.multitenant ? '| /tenant | GET | Get tenant info |' : ''}

**Database**: ${config.database === 'supabase' ? 'Supabase PostgreSQL' : 'Google Cloud SQL PostgreSQL'}

## Configuration

Backend URL is set via environment variable:

\`.env.local\`:
\`\`\`
NEXT_PUBLIC_API_URL=http://localhost:3001
\`\`\`

\`\`\`typescript
// lib/api-client.ts
const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';
\`\`\`

## CORS & Security

### Backend CORS Configuration

Your backend must allow requests from frontend:

\`\`\`typescript
// NestJS (auth-bp-nest)
@Module({
  controllers: [AuthController],
})
export class AuthModule {}

// In main.ts:
app.enableCors({
  origin: 'http://localhost:3000',
  credentials: true,
});
\`\`\`

### JWT Security

- JWT stored in encrypted NextAuth cookie
- Never exposed in localStorage
- Automatically included in requests
- Validated by backend

## Common Patterns

### Retry Failed Requests
\`\`\`typescript
const response = await apiClient.post('/endpoint', data)
  .catch(async (error) => {
    if (error.response?.status === 401) {
      // Could refresh token here
      return apiClient.post('/endpoint', data);
    }
    throw error;
  });
\`\`\`

### Custom Headers
\`\`\`typescript
await apiClient.post('/endpoint', data, {
  headers: {
    'X-Custom-Header': 'value',
  },
});
\`\`\`

### Timeout Configuration
\`\`\`typescript
const client = axios.create({
  baseURL: API_URL,
  timeout: 5000, // 5 second timeout
});
\`\`\`

## See Also
- Axios Documentation: https://axios-http.com
- NextAuth Session: https://next-auth.js.org/api/functions/get-session
- Backend: auth-bp-nest documentation
`;
}

export { buildMiddlewareContent } from './middleware-builder';
